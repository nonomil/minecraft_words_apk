#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const { DatabaseSync } = require("node:sqlite");

const ROOT = process.cwd();
const DB_PATH = path.join(ROOT, "data", "vocab.db");
const WEB_OUT_DIR = path.join(ROOT, "js", "vocabularies", "normalized");
const ANDROID_OUT_DIR = path.join(ROOT, "android-app", "web", "js", "vocabularies", "normalized");

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function readDbEntries() {
  const db = new DatabaseSync(DB_PATH);
  const entries = db
    .prepare(
      `SELECT id, lemma_key, word, standardized, chinese, phonetic, phrase, phrase_translation, difficulty, category
       FROM entries
       WHERE status='active'
       ORDER BY lemma_key`
    )
    .all();
  const srcStmt = db.prepare("SELECT source_group, source_file FROM entry_sources WHERE entry_id=? ORDER BY id");
  const imgStmt = db.prepare(
    "SELECT filename, url, type FROM entry_images WHERE entry_id=? ORDER BY is_primary DESC, id ASC"
  );

  return entries.map((e) => {
    const sources = srcStmt.all(e.id);
    const images = imgStmt.all(e.id);
    return {
      word: e.word || e.standardized || e.lemma_key,
      standardized: e.standardized || e.word || e.lemma_key,
      chinese: e.chinese || "",
      phonetic: e.phonetic || "",
      phrase: e.phrase || "",
      phraseTranslation: e.phrase_translation || "",
      difficulty: e.difficulty || "",
      category: e.category || "",
      imageURLs: images.map((x) => ({
        filename: x.filename || "",
        url: x.url || "",
        type: x.type || "",
      })),
      _sourceGroups: [...new Set(sources.map((s) => s.source_group || "other"))],
    };
  });
}

function pickBucket(entry) {
  const groups = Array.isArray(entry._sourceGroups) ? entry._sourceGroups : [];
  if (groups.includes("minecraft")) return "minecraft";
  if (groups.includes("kindergarten")) return "kindergarten";
  if (groups.includes("stage")) return "stage";
  if (groups.includes("common")) return "common";
  return "other";
}

function stripInternal(entry) {
  const { _sourceGroups, ...rest } = entry;
  return rest;
}

function buildRuntimePayload(entries) {
  const buckets = {
    minecraft: [],
    kindergarten: [],
    stage: [],
    common: [],
    other: [],
    all: [],
  };
  for (const e of entries) {
    const bucket = pickBucket(e);
    const clean = stripInternal(e);
    buckets[bucket].push(clean);
    buckets.all.push(clean);
  }
  return buckets;
}

function writeRuntimeFiles(outDir, payload) {
  ensureDir(outDir);

  const runtimeJs =
    "// Auto-generated by scripts/vocab_db/sync_db_to_runtime_vocab.js\n" +
    "// Runtime vocab bundles from data/vocab.db\n" +
    `const RUNTIME_VOCABULARIES = ${JSON.stringify(payload, null, 2)};\n`;

  const manifest = {
    generatedAt: new Date().toISOString(),
    groups: Object.fromEntries(
      Object.entries(payload).map(([k, v]) => [k, Array.isArray(v) ? v.length : 0])
    ),
  };

  fs.writeFileSync(path.join(outDir, "runtime_vocab.js"), runtimeJs, "utf8");
  fs.writeFileSync(
    path.join(outDir, "runtime_vocab_manifest.json"),
    JSON.stringify(manifest, null, 2),
    "utf8"
  );

  return manifest;
}

function main() {
  if (!fs.existsSync(DB_PATH)) {
    throw new Error("Missing data/vocab.db. Run npm run vocabdb:init first.");
  }
  const entries = readDbEntries();
  const payload = buildRuntimePayload(entries);

  const webManifest = writeRuntimeFiles(WEB_OUT_DIR, payload);
  const androidManifest = writeRuntimeFiles(ANDROID_OUT_DIR, payload);

  const summary = {
    generatedAt: new Date().toISOString(),
    database: path.relative(ROOT, DB_PATH),
    webOutDir: path.relative(ROOT, WEB_OUT_DIR),
    androidOutDir: path.relative(ROOT, ANDROID_OUT_DIR),
    entries: entries.length,
    groups: webManifest.groups,
    androidGroups: androidManifest.groups,
  };
  console.log(JSON.stringify(summary, null, 2));
}

main();

